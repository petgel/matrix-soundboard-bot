import type { MatrixClient } from "../client.ts";
import { type Room } from "../models/room.ts";
import { type CallMembership } from "./CallMembership.ts";
import { type Focus } from "./focus.ts";
import { type MembershipConfig } from "./MatrixRTCSession.ts";
/**
 * This interface defines what a MembershipManager uses and exposes.
 * This interface is what we use to write tests and allows to change the actual implementation
 * Without breaking tests because of some internal method renaming.
 *
 * @internal
 */
export interface IMembershipManager {
    /**
     * If we are trying to join the session.
     * It does not reflect if the room state is already configures to represent us being joined.
     * It only means that the Manager is running.
     * @returns true if we intend to be participating in the MatrixRTC session
     */
    isJoined(): boolean;
    /**
     * Start sending all necessary events to make this user participant in the RTC session.
     * @param fociPreferred the list of preferred foci to use in the joined RTC membership event.
     * @param fociActive the active focus to use in the joined RTC membership event.
     */
    join(fociPreferred: Focus[], fociActive?: Focus): void;
    /**
     * Send all necessary events to make this user leave the RTC session.
     * @param timeout the maximum duration in ms until the promise is forced to resolve.
     * @returns It resolves with true in case the leave was sent successfully.
     * It resolves with false in case we hit the timeout before sending successfully.
     */
    leave(timeout?: number): Promise<boolean>;
    /**
     * Call this if the MatrixRTC session members have changed.
     */
    onRTCSessionMemberUpdate(memberships: CallMembership[]): Promise<void>;
    /**
     * The used active focus in the currently joined session.
     * @returns the used active focus in the currently joined session or undefined if not joined.
     */
    getActiveFocus(): Focus | undefined;
}
/**
 * This internal class is used by the MatrixRTCSession to manage the local user's own membership of the session.
 *
 * Its responsibitiy is to manage the locals user membership:
 *  - send that sate event
 *  - send the delayed leave event
 *  - update the delayed leave event while connected
 *  - update the state event when it times out (for calls longer than membershipExpiryTimeout ~ 4h)
 *
 * It is possible to test this class on its own. The api surface (to use for tests) is
 * defined in `MembershipManagerInterface`.
 *
 * It is recommended to only use this interface for testing to allow replacing this class.
 *
 *  @internal
 */
export declare class LegacyMembershipManager implements IMembershipManager {
    private joinConfig;
    private room;
    private client;
    private getOldestMembership;
    private relativeExpiry;
    private memberEventTimeout?;
    /**
     *   This is a Foci array that contains the Focus objects this user is aware of and proposes to use.
     */
    private ownFociPreferred?;
    /**
     *   This is a Focus with the specified fields for an ActiveFocus (e.g. LivekitFocusActive for type="livekit")
     */
    private ownFocusActive?;
    private updateCallMembershipRunning;
    private needCallMembershipUpdate;
    /**
     * If the server disallows the configured {@link membershipServerSideExpiryTimeout},
     * this stores a delay that the server does allow.
     */
    private membershipServerSideExpiryTimeoutOverride?;
    private disconnectDelayId;
    private get callMemberEventRetryDelayMinimum();
    private get membershipExpiryTimeout();
    private get membershipServerSideExpiryTimeout();
    private get membershipKeepAlivePeriod();
    private get callMemberEventRetryJitter();
    constructor(joinConfig: MembershipConfig | undefined, room: Pick<Room, "getLiveTimeline" | "roomId" | "getVersion">, client: Pick<MatrixClient, "getUserId" | "getDeviceId" | "sendStateEvent" | "_unstable_sendDelayedStateEvent" | "_unstable_updateDelayedEvent">, getOldestMembership: () => CallMembership | undefined);
    isJoined(): boolean;
    join(fociPreferred: Focus[], fociActive?: Focus): void;
    leave(timeout?: number | undefined): Promise<boolean>;
    onRTCSessionMemberUpdate(memberships: CallMembership[]): Promise<void>;
    getActiveFocus(): Focus | undefined;
    private triggerCallMembershipEventUpdate;
    private makeNewMembership;
    /**
     * Constructs our own membership
     */
    private makeMyMembership;
    private updateCallMembershipEvent;
    private scheduleDelayDisconnection;
    private readonly delayDisconnection;
    private makeMembershipStateKey;
}
//# sourceMappingURL=MembershipManager.d.ts.map