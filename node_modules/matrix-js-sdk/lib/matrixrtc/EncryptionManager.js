import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { logger as rootLogger } from "../logger.js";
import { secureRandomBase64Url } from "../randomstring.js";
import { decodeBase64, encodeUnpaddedBase64 } from "../base64.js";
import { safeGetRetryAfterMs } from "../http-api/errors.js";
import { EventType } from "../@types/event.js";
var logger = rootLogger.getChild("MatrixRTCSession");

/**
 * A type collecting call encryption statistics for a session.
 */

/**
 * This interface is for testing and for making it possible to interchange the encryption manager.
 * @internal
 */

/**
 * This class implements the IEncryptionManager interface,
 * and takes care of managing the encryption keys of all rtc members:
 *  - generate new keys for the local user and send them to other participants
 *  - track all keys of all other members and update livekit.
 *
 * @internal
 */
export class EncryptionManager {
  get updateEncryptionKeyThrottle() {
    var _this$joinConfig$upda, _this$joinConfig;
    return (_this$joinConfig$upda = (_this$joinConfig = this.joinConfig) === null || _this$joinConfig === void 0 ? void 0 : _this$joinConfig.updateEncryptionKeyThrottle) !== null && _this$joinConfig$upda !== void 0 ? _this$joinConfig$upda : 3000;
  }
  get makeKeyDelay() {
    var _this$joinConfig$make, _this$joinConfig2;
    return (_this$joinConfig$make = (_this$joinConfig2 = this.joinConfig) === null || _this$joinConfig2 === void 0 ? void 0 : _this$joinConfig2.makeKeyDelay) !== null && _this$joinConfig$make !== void 0 ? _this$joinConfig$make : 3000;
  }
  get useKeyDelay() {
    var _this$joinConfig$useK, _this$joinConfig3;
    return (_this$joinConfig$useK = (_this$joinConfig3 = this.joinConfig) === null || _this$joinConfig3 === void 0 ? void 0 : _this$joinConfig3.useKeyDelay) !== null && _this$joinConfig$useK !== void 0 ? _this$joinConfig$useK : 5000;
  }
  constructor(client, room, getMemberships, onEncryptionKeysChanged) {
    var _this = this;
    this.client = client;
    this.room = room;
    this.getMemberships = getMemberships;
    this.onEncryptionKeysChanged = onEncryptionKeysChanged;
    _defineProperty(this, "manageMediaKeys", false);
    _defineProperty(this, "keysEventUpdateTimeout", void 0);
    _defineProperty(this, "makeNewKeyTimeout", void 0);
    _defineProperty(this, "setNewKeyTimeouts", new Set());
    _defineProperty(this, "encryptionKeys", new Map());
    _defineProperty(this, "lastEncryptionKeyUpdateRequest", void 0);
    // We use this to store the last membership fingerprints we saw, so we can proactively re-send encryption keys
    // if it looks like a membership has been updated.
    _defineProperty(this, "lastMembershipFingerprints", void 0);
    _defineProperty(this, "currentEncryptionKeyIndex", -1);
    _defineProperty(this, "statistics", {
      counters: {
        roomEventEncryptionKeysSent: 0,
        roomEventEncryptionKeysReceived: 0
      },
      totals: {
        roomEventEncryptionKeysReceivedTotalAge: 0
      }
    });
    _defineProperty(this, "joinConfig", void 0);
    _defineProperty(this, "joined", false);
    // TODO deduplicate this method. It also is in MatrixRTCSession.
    _defineProperty(this, "isMyMembership", m => m.sender === this.client.getUserId() && m.deviceId === this.client.getDeviceId());
    /**
     * Re-sends the encryption keys room event
     */
    _defineProperty(this, "sendEncryptionKeysEvent", /*#__PURE__*/function () {
      var _ref = _asyncToGenerator(function* (indexToSend) {
        if (_this.keysEventUpdateTimeout !== undefined) {
          clearTimeout(_this.keysEventUpdateTimeout);
          _this.keysEventUpdateTimeout = undefined;
        }
        _this.lastEncryptionKeyUpdateRequest = Date.now();
        if (!_this.joined) return;
        logger.info("Sending encryption keys event. indexToSend=".concat(indexToSend));
        var userId = _this.client.getUserId();
        var deviceId = _this.client.getDeviceId();
        if (!userId) throw new Error("No userId");
        if (!deviceId) throw new Error("No deviceId");
        var myKeys = _this.getKeysForParticipant(userId, deviceId);
        if (!myKeys) {
          logger.warn("Tried to send encryption keys event but no keys found!");
          return;
        }
        if (typeof indexToSend !== "number" && _this.currentEncryptionKeyIndex === -1) {
          logger.warn("Tried to send encryption keys event but no current key index found!");
          return;
        }
        var keyIndexToSend = indexToSend !== null && indexToSend !== void 0 ? indexToSend : _this.currentEncryptionKeyIndex;
        var keyToSend = myKeys[keyIndexToSend];
        try {
          var content = {
            keys: [{
              index: keyIndexToSend,
              key: encodeUnpaddedBase64(keyToSend)
            }],
            device_id: deviceId,
            call_id: "",
            sent_ts: Date.now()
          };
          _this.statistics.counters.roomEventEncryptionKeysSent += 1;
          yield _this.client.sendEvent(_this.room.roomId, EventType.CallEncryptionKeysPrefix, content);
          logger.debug("Embedded-E2EE-LOG updateEncryptionKeyEvent participantId=".concat(userId, ":").concat(deviceId, " numKeys=").concat(myKeys.length, " currentKeyIndex=").concat(_this.currentEncryptionKeyIndex, " keyIndexToSend=").concat(keyIndexToSend), _this.encryptionKeys);
        } catch (error) {
          var matrixError = error;
          if (matrixError.event) {
            // cancel the pending event: we'll just generate a new one with our latest
            // keys when we resend
            _this.client.cancelPendingEvent(matrixError.event);
          }
          if (_this.keysEventUpdateTimeout === undefined) {
            var resendDelay = safeGetRetryAfterMs(matrixError, 5000);
            logger.warn("Failed to send m.call.encryption_key, retrying in ".concat(resendDelay), error);
            _this.keysEventUpdateTimeout = setTimeout(() => void _this.sendEncryptionKeysEvent(), resendDelay);
          } else {
            logger.info("Not scheduling key resend as another re-send is already pending");
          }
        }
      });
      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }());
    _defineProperty(this, "onCallEncryptionEventReceived", event => {
      var userId = event.getSender();
      var content = event.getContent();
      var deviceId = content["device_id"];
      var callId = content["call_id"];
      if (!userId) {
        logger.warn("Received m.call.encryption_keys with no userId: callId=".concat(callId));
        return;
      }

      // We currently only handle callId = "" (which is the default for room scoped calls)
      if (callId !== "") {
        logger.warn("Received m.call.encryption_keys with unsupported callId: userId=".concat(userId, ", deviceId=").concat(deviceId, ", callId=").concat(callId));
        return;
      }
      if (!Array.isArray(content.keys)) {
        logger.warn("Received m.call.encryption_keys where keys wasn't an array: callId=".concat(callId));
        return;
      }
      if (userId === this.client.getUserId() && deviceId === this.client.getDeviceId()) {
        // We store our own sender key in the same set along with keys from others, so it's
        // important we don't allow our own keys to be set by one of these events (apart from
        // the fact that we don't need it anyway because we already know our own keys).
        logger.info("Ignoring our own keys event");
        return;
      }
      this.statistics.counters.roomEventEncryptionKeysReceived += 1;
      var age = Date.now() - (typeof content.sent_ts === "number" ? content.sent_ts : event.getTs());
      this.statistics.totals.roomEventEncryptionKeysReceivedTotalAge += age;
      for (var key of content.keys) {
        if (!key) {
          logger.info("Ignoring false-y key in keys event");
          continue;
        }
        var encryptionKey = key.key;
        var encryptionKeyIndex = key.index;
        if (!encryptionKey || encryptionKeyIndex === undefined || encryptionKeyIndex === null || callId === undefined || callId === null || typeof deviceId !== "string" || typeof callId !== "string" || typeof encryptionKey !== "string" || typeof encryptionKeyIndex !== "number") {
          logger.warn("Malformed call encryption_key: userId=".concat(userId, ", deviceId=").concat(deviceId, ", encryptionKeyIndex=").concat(encryptionKeyIndex, " callId=").concat(callId));
        } else {
          logger.debug("Embedded-E2EE-LOG onCallEncryption userId=".concat(userId, ":").concat(deviceId, " encryptionKeyIndex=").concat(encryptionKeyIndex, " age=").concat(age, "ms"), this.encryptionKeys);
          this.setEncryptionKey(userId, deviceId, encryptionKeyIndex, encryptionKey, event.getTs());
        }
      }
    });
    _defineProperty(this, "onRotateKeyTimeout", () => {
      if (!this.manageMediaKeys) return;
      this.makeNewKeyTimeout = undefined;
      logger.info("Making new sender key for key rotation");
      var newKeyIndex = this.makeNewSenderKey(true);
      // send immediately: if we're about to start sending with a new key, it's
      // important we get it out to others as soon as we can.
      void this.sendEncryptionKeysEvent(newKeyIndex);
    });
  }
  getEncryptionKeys() {
    return this.encryptionKeys;
  }
  join(joinConfig) {
    var _this$joinConfig$mana, _this$joinConfig4, _this$joinConfig5;
    this.joinConfig = joinConfig;
    this.joined = true;
    this.manageMediaKeys = (_this$joinConfig$mana = (_this$joinConfig4 = this.joinConfig) === null || _this$joinConfig4 === void 0 ? void 0 : _this$joinConfig4.manageMediaKeys) !== null && _this$joinConfig$mana !== void 0 ? _this$joinConfig$mana : this.manageMediaKeys;
    if ((_this$joinConfig5 = this.joinConfig) !== null && _this$joinConfig5 !== void 0 && _this$joinConfig5.manageMediaKeys) {
      this.makeNewSenderKey();
      this.requestSendCurrentKey();
    }
  }
  leave() {
    var userId = this.client.getUserId();
    var deviceId = this.client.getDeviceId();
    if (!userId) throw new Error("No userId");
    if (!deviceId) throw new Error("No deviceId");
    // clear our encryption keys as we're done with them now (we'll
    // make new keys if we rejoin). We leave keys for other participants
    // as they may still be using the same ones.
    this.encryptionKeys.set(getParticipantId(userId, deviceId), []);
    if (this.makeNewKeyTimeout !== undefined) {
      clearTimeout(this.makeNewKeyTimeout);
      this.makeNewKeyTimeout = undefined;
    }
    for (var t of this.setNewKeyTimeouts) {
      clearTimeout(t);
    }
    this.setNewKeyTimeouts.clear();
    this.manageMediaKeys = false;
    this.joined = false;
  }
  onMembershipsUpdate(oldMemberships) {
    if (this.manageMediaKeys && this.joined) {
      var oldMembershipIds = new Set(oldMemberships.filter(m => !this.isMyMembership(m)).map(getParticipantIdFromMembership));
      var newMembershipIds = new Set(this.getMemberships().filter(m => !this.isMyMembership(m)).map(getParticipantIdFromMembership));

      // We can use https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/symmetricDifference
      // for this once available
      var anyLeft = Array.from(oldMembershipIds).some(x => !newMembershipIds.has(x));
      var anyJoined = Array.from(newMembershipIds).some(x => !oldMembershipIds.has(x));
      var oldFingerprints = this.lastMembershipFingerprints;
      // always store the fingerprints of these latest memberships
      this.storeLastMembershipFingerprints();
      if (anyLeft) {
        if (this.makeNewKeyTimeout) {
          // existing rotation in progress, so let it complete
        } else {
          logger.debug("Member(s) have left: queueing sender key rotation");
          this.makeNewKeyTimeout = setTimeout(this.onRotateKeyTimeout, this.makeKeyDelay);
        }
      } else if (anyJoined) {
        logger.debug("New member(s) have joined: re-sending keys");
        this.requestSendCurrentKey();
      } else if (oldFingerprints) {
        // does it look like any of the members have updated their memberships?
        var newFingerprints = this.lastMembershipFingerprints;

        // We can use https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/symmetricDifference
        // for this once available
        var candidateUpdates = Array.from(oldFingerprints).some(x => !newFingerprints.has(x)) || Array.from(newFingerprints).some(x => !oldFingerprints.has(x));
        if (candidateUpdates) {
          logger.debug("Member(s) have updated/reconnected: re-sending keys to everyone");
          this.requestSendCurrentKey();
        }
      }
    }
  }

  /**
   * Generate a new sender key and add it at the next available index
   * @param delayBeforeUse - If true, wait for a short period before setting the key for the
   *                         media encryptor to use. If false, set the key immediately.
   * @returns The index of the new key
   */
  makeNewSenderKey() {
    var delayBeforeUse = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var userId = this.client.getUserId();
    var deviceId = this.client.getDeviceId();
    if (!userId) throw new Error("No userId");
    if (!deviceId) throw new Error("No deviceId");
    var encryptionKey = secureRandomBase64Url(16);
    var encryptionKeyIndex = this.getNewEncryptionKeyIndex();
    logger.info("Generated new key at index " + encryptionKeyIndex);
    this.setEncryptionKey(userId, deviceId, encryptionKeyIndex, encryptionKey, Date.now(), delayBeforeUse);
    return encryptionKeyIndex;
  }

  /**
   * Requests that we resend our current keys to the room. May send a keys event immediately
   * or queue for alter if one has already been sent recently.
   */
  requestSendCurrentKey() {
    if (!this.manageMediaKeys) return;
    if (this.lastEncryptionKeyUpdateRequest && this.lastEncryptionKeyUpdateRequest + this.updateEncryptionKeyThrottle > Date.now()) {
      logger.info("Last encryption key event sent too recently: postponing");
      if (this.keysEventUpdateTimeout === undefined) {
        this.keysEventUpdateTimeout = setTimeout(() => void this.sendEncryptionKeysEvent(), this.updateEncryptionKeyThrottle);
      }
      return;
    }
    void this.sendEncryptionKeysEvent();
  }

  /**
   * Get the known encryption keys for a given participant device.
   *
   * @param userId the user ID of the participant
   * @param deviceId the device ID of the participant
   * @returns The encryption keys for the given participant, or undefined if they are not known.
   */
  getKeysForParticipant(userId, deviceId) {
    var _this$encryptionKeys$;
    return (_this$encryptionKeys$ = this.encryptionKeys.get(getParticipantId(userId, deviceId))) === null || _this$encryptionKeys$ === void 0 ? void 0 : _this$encryptionKeys$.map(entry => entry.key);
  }
  storeLastMembershipFingerprints() {
    this.lastMembershipFingerprints = new Set(this.getMemberships().filter(m => !this.isMyMembership(m)).map(m => "".concat(getParticipantIdFromMembership(m), ":").concat(m.createdTs())));
  }
  getNewEncryptionKeyIndex() {
    if (this.currentEncryptionKeyIndex === -1) {
      return 0;
    }

    // maximum key index is 255
    return (this.currentEncryptionKeyIndex + 1) % 256;
  }

  /**
   * Sets an encryption key at a specified index for a participant.
   * The encryption keys for the local participant are also stored here under the
   * user and device ID of the local participant.
   * If the key is older than the existing key at the index, it will be ignored.
   * @param userId - The user ID of the participant
   * @param deviceId - Device ID of the participant
   * @param encryptionKeyIndex - The index of the key to set
   * @param encryptionKeyString - The string representation of the key to set in base64
   * @param timestamp - The timestamp of the key. We assume that these are monotonic for each participant device.
   * @param delayBeforeUse - If true, delay before emitting a key changed event. Useful when setting
   *                         encryption keys for the local participant to allow time for the key to
   *                         be distributed.
   */
  setEncryptionKey(userId, deviceId, encryptionKeyIndex, encryptionKeyString, timestamp) {
    var delayBeforeUse = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
    var keyBin = decodeBase64(encryptionKeyString);
    var participantId = getParticipantId(userId, deviceId);
    if (!this.encryptionKeys.has(participantId)) {
      this.encryptionKeys.set(participantId, []);
    }
    var participantKeys = this.encryptionKeys.get(participantId);
    var existingKeyAtIndex = participantKeys[encryptionKeyIndex];
    if (existingKeyAtIndex) {
      if (existingKeyAtIndex.timestamp > timestamp) {
        logger.info("Ignoring new key at index ".concat(encryptionKeyIndex, " for ").concat(participantId, " as it is older than existing known key"));
        return;
      }
      if (keysEqual(existingKeyAtIndex.key, keyBin)) {
        existingKeyAtIndex.timestamp = timestamp;
        return;
      }
    }
    participantKeys[encryptionKeyIndex] = {
      key: keyBin,
      timestamp
    };
    if (delayBeforeUse) {
      var useKeyTimeout = setTimeout(() => {
        this.setNewKeyTimeouts.delete(useKeyTimeout);
        logger.info("Delayed-emitting key changed event for ".concat(participantId, " idx ").concat(encryptionKeyIndex));
        if (userId === this.client.getUserId() && deviceId === this.client.getDeviceId()) {
          this.currentEncryptionKeyIndex = encryptionKeyIndex;
        }
        this.onEncryptionKeysChanged(keyBin, encryptionKeyIndex, participantId);
      }, this.useKeyDelay);
      this.setNewKeyTimeouts.add(useKeyTimeout);
    } else {
      if (userId === this.client.getUserId() && deviceId === this.client.getDeviceId()) {
        this.currentEncryptionKeyIndex = encryptionKeyIndex;
      }
      this.onEncryptionKeysChanged(keyBin, encryptionKeyIndex, participantId);
    }
  }
}
var getParticipantId = (userId, deviceId) => "".concat(userId, ":").concat(deviceId);
function keysEqual(a, b) {
  if (a === b) return true;
  return !!a && !!b && a.length === b.length && a.every((x, i) => x === b[i]);
}
var getParticipantIdFromMembership = m => getParticipantId(m.sender, m.deviceId);
//# sourceMappingURL=EncryptionManager.js.map