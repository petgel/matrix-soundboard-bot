{"version":3,"file":"MembershipManager.js","names":["EventType","UpdateDelayedEventAction","HTTPError","MatrixError","logger","EventTimeline","sleep","DEFAULT_EXPIRE_DURATION","isLivekitFocusActive","LegacyMembershipManager","callMemberEventRetryDelayMinimum","_this$joinConfig$call","_this$joinConfig","joinConfig","membershipExpiryTimeout","_this$joinConfig$memb","_this$joinConfig2","membershipServerSideExpiryTimeout","_ref","_this$membershipServe","_this$joinConfig3","membershipServerSideExpiryTimeoutOverride","membershipKeepAlivePeriod","_this$joinConfig$memb2","_this$joinConfig4","callMemberEventRetryJitter","_this$joinConfig$call2","_this$joinConfig5","constructor","room","client","getOldestMembership","_this","_defineProperty","_asyncToGenerator","updateCallMembershipRunning","needCallMembershipUpdate","updateCallMembershipEvent","knownDisconnectDelayId","disconnectDelayId","resendIfRateLimited","_unstable_updateDelayedEvent","Restart","scheduleDelayDisconnection","e","error","isJoined","relativeExpiry","undefined","join","fociPreferred","fociActive","ownFocusActive","ownFociPreferred","triggerCallMembershipEventUpdate","leave","_arguments","arguments","_this2","timeout","length","memberEventTimeout","clearTimeout","raceResult","Promise","race","onRTCSessionMemberUpdate","memberships","_this3","isMyMembership","m","sender","getUserId","deviceId","getDeviceId","some","warn","getActiveFocus","focus_selection","oldestMembership","getPreferredFoci","makeNewMembership","makeMyMembership","_this$ownFociPreferre","call_id","scope","application","device_id","expires","focus_active","type","foci_preferred","_this4","roomState","getLiveTimeline","getState","FORWARDS","Error","roomId","localUserId","localDeviceId","newContent","stateKey","makeMembershipStateKey","prepareDelayedDisconnection","_ref4","res","_unstable_sendDelayedStateEvent","delay","GroupCallMemberPrefix","delay_id","errcode","data","maxDelayAllowed","apply","sendStateEvent","sentDelayedDisconnect","Send","info","resendDelay","Math","random","concat","setTimeout","delayDisconnection","exec","getVersion","_x","_resendIfRateLimited","func","numRetriesAllowed","isRateLimitError","defaultMs","_e$getRetryAfterMs","getRetryAfterMs"],"sources":["../../src/matrixrtc/MembershipManager.ts"],"sourcesContent":["import { EventType } from \"../@types/event.ts\";\nimport { UpdateDelayedEventAction } from \"../@types/requests.ts\";\nimport type { MatrixClient } from \"../client.ts\";\nimport { HTTPError, MatrixError } from \"../http-api/errors.ts\";\nimport { logger } from \"../logger.ts\";\nimport { EventTimeline } from \"../models/event-timeline.ts\";\nimport { type Room } from \"../models/room.ts\";\nimport { sleep } from \"../utils.ts\";\nimport { type CallMembership, DEFAULT_EXPIRE_DURATION, type SessionMembershipData } from \"./CallMembership.ts\";\nimport { type Focus } from \"./focus.ts\";\nimport { isLivekitFocusActive } from \"./LivekitFocus.ts\";\nimport { type MembershipConfig } from \"./MatrixRTCSession.ts\";\nimport { type EmptyObject } from \"../@types/common.ts\";\n/**\n * This interface defines what a MembershipManager uses and exposes.\n * This interface is what we use to write tests and allows to change the actual implementation\n * Without breaking tests because of some internal method renaming.\n *\n * @internal\n */\nexport interface IMembershipManager {\n    /**\n     * If we are trying to join the session.\n     * It does not reflect if the room state is already configures to represent us being joined.\n     * It only means that the Manager is running.\n     * @returns true if we intend to be participating in the MatrixRTC session\n     */\n    isJoined(): boolean;\n    /**\n     * Start sending all necessary events to make this user participant in the RTC session.\n     * @param fociPreferred the list of preferred foci to use in the joined RTC membership event.\n     * @param fociActive the active focus to use in the joined RTC membership event.\n     */\n    join(fociPreferred: Focus[], fociActive?: Focus): void;\n    /**\n     * Send all necessary events to make this user leave the RTC session.\n     * @param timeout the maximum duration in ms until the promise is forced to resolve.\n     * @returns It resolves with true in case the leave was sent successfully.\n     * It resolves with false in case we hit the timeout before sending successfully.\n     */\n    leave(timeout?: number): Promise<boolean>;\n    /**\n     * Call this if the MatrixRTC session members have changed.\n     */\n    onRTCSessionMemberUpdate(memberships: CallMembership[]): Promise<void>;\n    /**\n     * The used active focus in the currently joined session.\n     * @returns the used active focus in the currently joined session or undefined if not joined.\n     */\n    getActiveFocus(): Focus | undefined;\n}\n\n/**\n * This internal class is used by the MatrixRTCSession to manage the local user's own membership of the session.\n *\n * Its responsibitiy is to manage the locals user membership:\n *  - send that sate event\n *  - send the delayed leave event\n *  - update the delayed leave event while connected\n *  - update the state event when it times out (for calls longer than membershipExpiryTimeout ~ 4h)\n *\n * It is possible to test this class on its own. The api surface (to use for tests) is\n * defined in `MembershipManagerInterface`.\n *\n * It is recommended to only use this interface for testing to allow replacing this class.\n *\n *  @internal\n */\nexport class LegacyMembershipManager implements IMembershipManager {\n    private relativeExpiry: number | undefined;\n\n    private memberEventTimeout?: ReturnType<typeof setTimeout>;\n\n    /**\n     *   This is a Foci array that contains the Focus objects this user is aware of and proposes to use.\n     */\n    private ownFociPreferred?: Focus[];\n    /**\n     *   This is a Focus with the specified fields for an ActiveFocus (e.g. LivekitFocusActive for type=\"livekit\")\n     */\n    private ownFocusActive?: Focus;\n\n    private updateCallMembershipRunning = false;\n    private needCallMembershipUpdate = false;\n    /**\n     * If the server disallows the configured {@link membershipServerSideExpiryTimeout},\n     * this stores a delay that the server does allow.\n     */\n    private membershipServerSideExpiryTimeoutOverride?: number;\n    private disconnectDelayId: string | undefined;\n\n    private get callMemberEventRetryDelayMinimum(): number {\n        return this.joinConfig?.callMemberEventRetryDelayMinimum ?? 3_000;\n    }\n    private get membershipExpiryTimeout(): number {\n        return this.joinConfig?.membershipExpiryTimeout ?? DEFAULT_EXPIRE_DURATION;\n    }\n    private get membershipServerSideExpiryTimeout(): number {\n        return (\n            this.membershipServerSideExpiryTimeoutOverride ??\n            this.joinConfig?.membershipServerSideExpiryTimeout ??\n            8_000\n        );\n    }\n    private get membershipKeepAlivePeriod(): number {\n        return this.joinConfig?.membershipKeepAlivePeriod ?? 5_000;\n    }\n    private get callMemberEventRetryJitter(): number {\n        return this.joinConfig?.callMemberEventRetryJitter ?? 2_000;\n    }\n\n    public constructor(\n        private joinConfig: MembershipConfig | undefined,\n        private room: Pick<Room, \"getLiveTimeline\" | \"roomId\" | \"getVersion\">,\n        private client: Pick<\n            MatrixClient,\n            | \"getUserId\"\n            | \"getDeviceId\"\n            | \"sendStateEvent\"\n            | \"_unstable_sendDelayedStateEvent\"\n            | \"_unstable_updateDelayedEvent\"\n        >,\n        private getOldestMembership: () => CallMembership | undefined,\n    ) {}\n\n    public isJoined(): boolean {\n        return this.relativeExpiry !== undefined;\n    }\n\n    public join(fociPreferred: Focus[], fociActive?: Focus): void {\n        this.ownFocusActive = fociActive;\n        this.ownFociPreferred = fociPreferred;\n        this.relativeExpiry = this.membershipExpiryTimeout;\n        // We don't wait for this, mostly because it may fail and schedule a retry, so this\n        // function returning doesn't really mean anything at all.\n        void this.triggerCallMembershipEventUpdate();\n    }\n\n    public async leave(timeout: number | undefined = undefined): Promise<boolean> {\n        this.relativeExpiry = undefined;\n        this.ownFocusActive = undefined;\n\n        if (this.memberEventTimeout) {\n            clearTimeout(this.memberEventTimeout);\n            this.memberEventTimeout = undefined;\n        }\n        if (timeout) {\n            // The sleep promise returns the string 'timeout' and the membership update void\n            // A success implies that the membership update was quicker then the timeout.\n            const raceResult = await Promise.race([this.triggerCallMembershipEventUpdate(), sleep(timeout, \"timeout\")]);\n            return raceResult !== \"timeout\";\n        } else {\n            await this.triggerCallMembershipEventUpdate();\n            return true;\n        }\n    }\n\n    public async onRTCSessionMemberUpdate(memberships: CallMembership[]): Promise<void> {\n        const isMyMembership = (m: CallMembership): boolean =>\n            m.sender === this.client.getUserId() && m.deviceId === this.client.getDeviceId();\n\n        if (this.isJoined() && !memberships.some(isMyMembership)) {\n            logger.warn(\"Missing own membership: force re-join\");\n            // TODO: Should this be awaited? And is there anything to tell the focus?\n            return this.triggerCallMembershipEventUpdate();\n        }\n    }\n\n    public getActiveFocus(): Focus | undefined {\n        if (this.ownFocusActive) {\n            // A livekit active focus\n            if (isLivekitFocusActive(this.ownFocusActive)) {\n                if (this.ownFocusActive.focus_selection === \"oldest_membership\") {\n                    const oldestMembership = this.getOldestMembership();\n                    return oldestMembership?.getPreferredFoci()[0];\n                }\n            } else {\n                logger.warn(\"Unknown own ActiveFocus type. This makes it impossible to connect to an SFU.\");\n            }\n        } else {\n            // We do not understand the membership format (could be legacy). We default to oldestMembership\n            // Once there are other methods this is a hard error!\n            const oldestMembership = this.getOldestMembership();\n            return oldestMembership?.getPreferredFoci()[0];\n        }\n    }\n\n    private triggerCallMembershipEventUpdate = async (): Promise<void> => {\n        // TODO: Should this await on a shared promise?\n        if (this.updateCallMembershipRunning) {\n            this.needCallMembershipUpdate = true;\n            return;\n        }\n\n        this.updateCallMembershipRunning = true;\n        try {\n            // if anything triggers an update while the update is running, do another update afterwards\n            do {\n                this.needCallMembershipUpdate = false;\n                await this.updateCallMembershipEvent();\n            } while (this.needCallMembershipUpdate);\n        } finally {\n            this.updateCallMembershipRunning = false;\n        }\n    };\n    private makeNewMembership(deviceId: string): SessionMembershipData | EmptyObject {\n        // If we're joined, add our own\n        if (this.isJoined()) {\n            return this.makeMyMembership(deviceId);\n        }\n        return {};\n    }\n\n    /**\n     * Constructs our own membership\n     */\n    private makeMyMembership(deviceId: string): SessionMembershipData {\n        return {\n            call_id: \"\",\n            scope: \"m.room\",\n            application: \"m.call\",\n            device_id: deviceId,\n            expires: this.relativeExpiry,\n            focus_active: { type: \"livekit\", focus_selection: \"oldest_membership\" },\n            foci_preferred: this.ownFociPreferred ?? [],\n        };\n    }\n\n    private async updateCallMembershipEvent(): Promise<void> {\n        if (this.memberEventTimeout) {\n            clearTimeout(this.memberEventTimeout);\n            this.memberEventTimeout = undefined;\n        }\n\n        const roomState = this.room.getLiveTimeline().getState(EventTimeline.FORWARDS);\n        if (!roomState) throw new Error(\"Couldn't get room state for room \" + this.room.roomId);\n\n        const localUserId = this.client.getUserId();\n        const localDeviceId = this.client.getDeviceId();\n        if (!localUserId || !localDeviceId) throw new Error(\"User ID or device ID was null!\");\n\n        let newContent: EmptyObject | SessionMembershipData = {};\n        // TODO: add back expiary logic to non-legacy events\n        // previously we checked here if the event is timed out and scheduled a check if not.\n        // maybe there is a better way.\n        newContent = this.makeNewMembership(localDeviceId);\n\n        try {\n            if (this.isJoined()) {\n                const stateKey = this.makeMembershipStateKey(localUserId, localDeviceId);\n                const prepareDelayedDisconnection = async (): Promise<void> => {\n                    try {\n                        const res = await resendIfRateLimited(() =>\n                            this.client._unstable_sendDelayedStateEvent(\n                                this.room.roomId,\n                                {\n                                    delay: this.membershipServerSideExpiryTimeout,\n                                },\n                                EventType.GroupCallMemberPrefix,\n                                {}, // leave event\n                                stateKey,\n                            ),\n                        );\n                        this.disconnectDelayId = res.delay_id;\n                    } catch (e) {\n                        if (\n                            e instanceof MatrixError &&\n                            e.errcode === \"M_UNKNOWN\" &&\n                            e.data[\"org.matrix.msc4140.errcode\"] === \"M_MAX_DELAY_EXCEEDED\"\n                        ) {\n                            const maxDelayAllowed = e.data[\"org.matrix.msc4140.max_delay\"];\n                            if (\n                                typeof maxDelayAllowed === \"number\" &&\n                                this.membershipServerSideExpiryTimeout > maxDelayAllowed\n                            ) {\n                                this.membershipServerSideExpiryTimeoutOverride = maxDelayAllowed;\n                                return prepareDelayedDisconnection();\n                            }\n                        }\n                        logger.error(\"Failed to prepare delayed disconnection event:\", e);\n                    }\n                };\n\n                await prepareDelayedDisconnection();\n                // Send join event _after_ preparing the delayed disconnection event\n                await resendIfRateLimited(() =>\n                    this.client.sendStateEvent(this.room.roomId, EventType.GroupCallMemberPrefix, newContent, stateKey),\n                );\n                // If sending state cancels your own delayed state, prepare another delayed state\n                // TODO: Remove this once MSC4140 is stable & doesn't cancel own delayed state\n                if (this.disconnectDelayId !== undefined) {\n                    try {\n                        const knownDisconnectDelayId = this.disconnectDelayId;\n                        await resendIfRateLimited(() =>\n                            this.client._unstable_updateDelayedEvent(\n                                knownDisconnectDelayId,\n                                UpdateDelayedEventAction.Restart,\n                            ),\n                        );\n                    } catch (e) {\n                        if (e instanceof MatrixError && e.errcode === \"M_NOT_FOUND\") {\n                            // If we get a M_NOT_FOUND we prepare a new delayed event.\n                            // In other error cases we do not want to prepare anything since we do not have the guarantee, that the\n                            // future is not still running.\n                            logger.warn(\"Failed to update delayed disconnection event, prepare it again:\", e);\n                            this.disconnectDelayId = undefined;\n                            await prepareDelayedDisconnection();\n                        }\n                    }\n                }\n                if (this.disconnectDelayId !== undefined) {\n                    this.scheduleDelayDisconnection();\n                }\n                // TODO throw or log an error if this.disconnectDelayId === undefined\n            } else {\n                // Not joined\n                let sentDelayedDisconnect = false;\n                if (this.disconnectDelayId !== undefined) {\n                    try {\n                        const knownDisconnectDelayId = this.disconnectDelayId;\n                        await resendIfRateLimited(() =>\n                            this.client._unstable_updateDelayedEvent(\n                                knownDisconnectDelayId,\n                                UpdateDelayedEventAction.Send,\n                            ),\n                        );\n                        sentDelayedDisconnect = true;\n                    } catch (e) {\n                        logger.error(\"Failed to send our delayed disconnection event:\", e);\n                    }\n                    this.disconnectDelayId = undefined;\n                }\n                if (!sentDelayedDisconnect) {\n                    await resendIfRateLimited(() =>\n                        this.client.sendStateEvent(\n                            this.room.roomId,\n                            EventType.GroupCallMemberPrefix,\n                            {},\n                            this.makeMembershipStateKey(localUserId, localDeviceId),\n                        ),\n                    );\n                }\n            }\n            logger.info(\"Sent updated call member event.\");\n        } catch (e) {\n            const resendDelay = this.callMemberEventRetryDelayMinimum + Math.random() * this.callMemberEventRetryJitter;\n            logger.warn(`Failed to send call member event (retrying in ${resendDelay}): ${e}`);\n            await sleep(resendDelay);\n            await this.triggerCallMembershipEventUpdate();\n        }\n    }\n\n    private scheduleDelayDisconnection(): void {\n        this.memberEventTimeout = setTimeout(() => void this.delayDisconnection(), this.membershipKeepAlivePeriod);\n    }\n\n    private readonly delayDisconnection = async (): Promise<void> => {\n        try {\n            const knownDisconnectDelayId = this.disconnectDelayId!;\n            await resendIfRateLimited(() =>\n                this.client._unstable_updateDelayedEvent(knownDisconnectDelayId, UpdateDelayedEventAction.Restart),\n            );\n            this.scheduleDelayDisconnection();\n        } catch (e) {\n            logger.error(\"Failed to delay our disconnection event:\", e);\n        }\n    };\n\n    private makeMembershipStateKey(localUserId: string, localDeviceId: string): string {\n        const stateKey = `${localUserId}_${localDeviceId}`;\n        if (/^org\\.matrix\\.msc(3757|3779)\\b/.exec(this.room.getVersion())) {\n            return stateKey;\n        } else {\n            return `_${stateKey}`;\n        }\n    }\n}\n\nasync function resendIfRateLimited<T>(func: () => Promise<T>, numRetriesAllowed: number = 1): Promise<T> {\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        try {\n            return await func();\n        } catch (e) {\n            if (numRetriesAllowed > 0 && e instanceof HTTPError && e.isRateLimitError()) {\n                numRetriesAllowed--;\n                let resendDelay: number;\n                const defaultMs = 5000;\n                try {\n                    resendDelay = e.getRetryAfterMs() ?? defaultMs;\n                    logger.info(`Rate limited by server, retrying in ${resendDelay}ms`);\n                } catch (e) {\n                    logger.warn(\n                        `Error while retrieving a rate-limit retry delay, retrying after default delay of ${defaultMs}`,\n                        e,\n                    );\n                    resendDelay = defaultMs;\n                }\n                await sleep(resendDelay);\n            } else {\n                throw e;\n            }\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]}