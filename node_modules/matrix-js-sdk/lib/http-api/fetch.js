import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
var _FetchHttpApi;
var _initProto;
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _applyDecs(e, t, n, r, o, i) { var a, c, u, s, f, l, p, d = Symbol.metadata || Symbol.for("Symbol.metadata"), m = Object.defineProperty, h = Object.create, y = [h(null), h(null)], v = t.length; function g(t, n, r) { return function (o, i) { n && (i = o, o = e); for (var a = 0; a < t.length; a++) i = t[a].apply(o, r ? [i] : []); return r ? i : o; }; } function b(e, t, n, r) { if ("function" != typeof e && (r || void 0 !== e)) throw new TypeError(t + " must " + (n || "be") + " a function" + (r ? "" : " or undefined")); return e; } function applyDec(e, t, n, r, o, i, u, s, f, l, p) { function d(e) { if (!p(e)) throw new TypeError("Attempted to access private element on non-instance"); } var h = [].concat(t[0]), v = t[3], w = !u, D = 1 === o, S = 3 === o, j = 4 === o, E = 2 === o; function I(t, n, r) { return function (o, i) { return n && (i = o, o = e), r && r(o), P[t].call(o, i); }; } if (!w) { var P = {}, k = [], F = S ? "get" : j || D ? "set" : "value"; if (f ? (l || D ? P = { get: _setFunctionName(function () { return v(this); }, r, "get"), set: function set(e) { t[4](this, e); } } : P[F] = v, l || _setFunctionName(P[F], r, E ? "" : F)) : l || (P = Object.getOwnPropertyDescriptor(e, r)), !l && !f) { if ((c = y[+s][r]) && 7 != (c ^ o)) throw Error("Decorating two elements with the same name (" + P[F].name + ") is not supported yet"); y[+s][r] = o < 3 ? 1 : o; } } for (var N = e, O = h.length - 1; O >= 0; O -= n ? 2 : 1) { var T = b(h[O], "A decorator", "be", !0), z = n ? h[O - 1] : void 0, A = {}, H = { kind: ["field", "accessor", "method", "getter", "setter", "class"][o], name: r, metadata: a, addInitializer: function (e, t) { if (e.v) throw new TypeError("attempted to call addInitializer after decoration was finished"); b(t, "An initializer", "be", !0), i.push(t); }.bind(null, A) }; if (w) c = T.call(z, N, H), A.v = 1, b(c, "class decorators", "return") && (N = c);else if (H.static = s, H.private = f, c = H.access = { has: f ? p.bind() : function (e) { return r in e; } }, j || (c.get = f ? E ? function (e) { return d(e), P.value; } : I("get", 0, d) : function (e) { return e[r]; }), E || S || (c.set = f ? I("set", 0, d) : function (e, t) { e[r] = t; }), N = T.call(z, D ? { get: P.get, set: P.set } : P[F], H), A.v = 1, D) { if ("object" == typeof N && N) (c = b(N.get, "accessor.get")) && (P.get = c), (c = b(N.set, "accessor.set")) && (P.set = c), (c = b(N.init, "accessor.init")) && k.unshift(c);else if (void 0 !== N) throw new TypeError("accessor decorators must return an object with get, set, or init properties or undefined"); } else b(N, (l ? "field" : "method") + " decorators", "return") && (l ? k.unshift(N) : P[F] = N); } return o < 2 && u.push(g(k, s, 1), g(i, s, 0)), l || w || (f ? D ? u.splice(-1, 0, I("get", s), I("set", s)) : u.push(E ? P[F] : b.call.bind(P[F])) : m(e, r, P)), N; } function w(e) { return m(e, d, { configurable: !0, enumerable: !0, value: a }); } return void 0 !== i && (a = i[d]), a = h(null == a ? null : a), f = [], l = function l(e) { e && f.push(g(e)); }, p = function p(t, r) { for (var i = 0; i < n.length; i++) { var a = n[i], c = a[1], l = 7 & c; if ((8 & c) == t && !l == r) { var p = a[2], d = !!a[3], m = 16 & c; applyDec(t ? e : e.prototype, a, m, d ? "#" + p : _toPropertyKey(p), l, l < 2 ? [] : t ? s = s || [] : u = u || [], f, !!t, d, r, t && d ? function (t) { return _checkInRHS(t) === e; } : o); } } }, p(8, 0), p(0, 0), p(8, 1), p(0, 1), l(u), l(s), c = f, v || w(e), { e: c, get c() { var n = []; return v && [w(e = applyDec(e, [t], r, e.name, 5, n)), g(n, 1)]; } }; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _setFunctionName(e, t, n) { "symbol" == typeof t && (t = (t = t.description) ? "[" + t + "]" : ""); try { Object.defineProperty(e, "name", { configurable: !0, value: n ? n + " " + t : t }); } catch (e) {} return e; }
function _checkInRHS(e) { if (Object(e) !== e) throw TypeError("right-hand side of 'in' should be an object, got " + (null !== e ? typeof e : "null")); return e; }
/*
Copyright 2022 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/**
 * This is an internal module. See {@link MatrixHttpApi} for the public class.
 */

import { ErrorResponse as OidcAuthError } from "oidc-client-ts";
import { checkObjectHasKeys, encodeParams } from "../utils.js";
import { Method } from "./method.js";
import { ConnectionError, MatrixError, TokenRefreshError } from "./errors.js";
import { HttpApiEvent } from "./interface.js";
import { anySignal, parseErrorResponse, timeoutSignal } from "./utils.js";
import { singleAsyncExecution } from "../utils/decorators.js";
var TokenRefreshOutcome = /*#__PURE__*/function (TokenRefreshOutcome) {
  TokenRefreshOutcome["Success"] = "success";
  TokenRefreshOutcome["Failure"] = "failure";
  TokenRefreshOutcome["Logout"] = "logout";
  return TokenRefreshOutcome;
}(TokenRefreshOutcome || {});
export class FetchHttpApi {
  constructor(eventEmitter, opts) {
    var _opts$useAuthorizatio;
    this.eventEmitter = eventEmitter;
    this.opts = opts;
    _defineProperty(this, "abortController", (_initProto(this), new AbortController()));
    /**
     * Promise used to block authenticated requests during a token refresh to avoid repeated expected errors.
     * @private
     */
    _defineProperty(this, "tokenRefreshPromise", void 0);
    checkObjectHasKeys(opts, ["baseUrl", "prefix"]);
    opts.onlyData = !!opts.onlyData;
    opts.useAuthorizationHeader = (_opts$useAuthorizatio = opts.useAuthorizationHeader) !== null && _opts$useAuthorizatio !== void 0 ? _opts$useAuthorizatio : true;
  }
  abort() {
    this.abortController.abort();
    this.abortController = new AbortController();
  }
  fetch(resource, options) {
    if (this.opts.fetchFn) {
      return this.opts.fetchFn(resource, options);
    }
    return globalThis.fetch(resource, options);
  }

  /**
   * Sets the base URL for the identity server
   * @param url - The new base url
   */
  setIdBaseUrl(url) {
    this.opts.idBaseUrl = url;
  }
  idServerRequest(method, path, params, prefix, accessToken) {
    if (!this.opts.idBaseUrl) {
      throw new Error("No identity server base URL set");
    }
    var queryParams = undefined;
    var body = undefined;
    if (method === Method.Get) {
      queryParams = params;
    } else {
      body = params;
    }
    var fullUri = this.getUrl(path, queryParams, prefix, this.opts.idBaseUrl);
    var opts = {
      json: true,
      headers: {}
    };
    if (accessToken) {
      opts.headers.Authorization = "Bearer ".concat(accessToken);
    }
    return this.requestOtherUrl(method, fullUri, body, opts);
  }
  /**
   * Perform an authorised request to the homeserver.
   * @param method - The HTTP method e.g. "GET".
   * @param path - The HTTP path <b>after</b> the supplied prefix e.g.
   * "/createRoom".
   *
   * @param queryParams - A dict of query params (these will NOT be
   * urlencoded). If unspecified, there will be no query params.
   *
   * @param body - The HTTP JSON body.
   *
   * @param paramOpts - additional options.
   * When `paramOpts.doNotAttemptTokenRefresh` is true, token refresh will not be attempted
   * when an expired token is encountered. Used to only attempt token refresh once.
   *
   * @returns Promise which resolves to
   * ```
   * {
   *     data: {Object},
   *     headers: {Object},
   *     code: {Number},
   * }
   * ```
   * If `onlyData` is set, this will resolve to the `data` object only.
   * @returns Rejects with an error if a problem occurred.
   * This includes network problems and Matrix-specific error JSON.
   */
  authedRequest(method, path, queryParams, body) {
    var _arguments = arguments,
      _this = this;
    return _asyncToGenerator(function* () {
      var paramOpts = _arguments.length > 4 && _arguments[4] !== undefined ? _arguments[4] : {};
      if (!queryParams) queryParams = {};

      // avoid mutating paramOpts so they can be used on retry
      var opts = _objectSpread({}, paramOpts);
      if (_this.opts.accessToken) {
        if (_this.opts.useAuthorizationHeader) {
          if (!opts.headers) {
            opts.headers = {};
          }
          if (!opts.headers.Authorization) {
            opts.headers.Authorization = "Bearer " + _this.opts.accessToken;
          }
          if (queryParams.access_token) {
            delete queryParams.access_token;
          }
        } else if (!queryParams.access_token) {
          queryParams.access_token = _this.opts.accessToken;
        }
      }
      try {
        // Await any ongoing token refresh
        yield _this.tokenRefreshPromise;
        var response = yield _this.request(method, path, queryParams, body, opts);
        return response;
      } catch (error) {
        if (!(error instanceof MatrixError)) {
          throw error;
        }
        if (error.errcode === "M_UNKNOWN_TOKEN" && !opts.doNotAttemptTokenRefresh) {
          var tokenRefreshPromise = _this.tryRefreshToken();
          _this.tokenRefreshPromise = Promise.allSettled([tokenRefreshPromise]);
          var outcome = yield tokenRefreshPromise;
          if (outcome === TokenRefreshOutcome.Success) {
            // if we got a new token retry the request
            return _this.authedRequest(method, path, queryParams, body, _objectSpread(_objectSpread({}, paramOpts), {}, {
              doNotAttemptTokenRefresh: true
            }));
          }
          if (outcome === TokenRefreshOutcome.Failure) {
            throw new TokenRefreshError(error);
          }
          // Fall through to SessionLoggedOut handler below
        }

        // otherwise continue with error handling
        if (error.errcode == "M_UNKNOWN_TOKEN" && !(opts !== null && opts !== void 0 && opts.inhibitLogoutEmit)) {
          _this.eventEmitter.emit(HttpApiEvent.SessionLoggedOut, error);
        } else if (error.errcode == "M_CONSENT_NOT_GIVEN") {
          _this.eventEmitter.emit(HttpApiEvent.NoConsent, error.message, error.data.consent_uri);
        }
        throw error;
      }
    })();
  }

  /**
   * Attempt to refresh access tokens.
   * On success, sets new access and refresh tokens in opts.
   * @returns Promise that resolves to a boolean - true when token was refreshed successfully
   */
  tryRefreshToken() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      if (!_this2.opts.refreshToken || !_this2.opts.tokenRefreshFunction) {
        return TokenRefreshOutcome.Logout;
      }
      try {
        var {
          accessToken,
          refreshToken
        } = yield _this2.opts.tokenRefreshFunction(_this2.opts.refreshToken);
        _this2.opts.accessToken = accessToken;
        _this2.opts.refreshToken = refreshToken;
        // successfully got new tokens
        return TokenRefreshOutcome.Success;
      } catch (error) {
        var _this2$opts$logger;
        (_this2$opts$logger = _this2.opts.logger) === null || _this2$opts$logger === void 0 || _this2$opts$logger.warn("Failed to refresh token", error);
        if (error instanceof OidcAuthError || error instanceof MatrixError) {
          return TokenRefreshOutcome.Logout;
        }
        return TokenRefreshOutcome.Failure;
      }
    })();
  }

  /**
   * Perform a request to the homeserver without any credentials.
   * @param method - The HTTP method e.g. "GET".
   * @param path - The HTTP path <b>after</b> the supplied prefix e.g.
   * "/createRoom".
   *
   * @param queryParams - A dict of query params (these will NOT be
   * urlencoded). If unspecified, there will be no query params.
   *
   * @param body - The HTTP JSON body.
   *
   * @param opts - additional options
   *
   * @returns Promise which resolves to
   * ```
   * {
   *  data: {Object},
   *  headers: {Object},
   *  code: {Number},
   * }
   * ```
   * If `onlyData</code> is set, this will resolve to the <code>data`
   * object only.
   * @returns Rejects with an error if a problem
   * occurred. This includes network problems and Matrix-specific error JSON.
   */
  request(method, path, queryParams, body, opts) {
    var fullUri = this.getUrl(path, queryParams, opts === null || opts === void 0 ? void 0 : opts.prefix, opts === null || opts === void 0 ? void 0 : opts.baseUrl);
    return this.requestOtherUrl(method, fullUri, body, opts);
  }

  /**
   * Perform a request to an arbitrary URL.
   * @param method - The HTTP method e.g. "GET".
   * @param url - The HTTP URL object.
   *
   * @param body - The HTTP JSON body.
   *
   * @param opts - additional options
   *
   * @returns Promise which resolves to data unless `onlyData` is specified as false,
   * where the resolved value will be a fetch Response object.
   * @returns Rejects with an error if a problem
   * occurred. This includes network problems and Matrix-specific error JSON.
   */
  requestOtherUrl(method, url, body) {
    var _arguments2 = arguments,
      _this3 = this;
    return _asyncToGenerator(function* () {
      var _this3$opts$logger, _opts$json, _body$constructor, _opts$localTimeoutMs, _opts$keepAlive;
      var opts = _arguments2.length > 3 && _arguments2[3] !== undefined ? _arguments2[3] : {};
      var urlForLogs = _this3.sanitizeUrlForLogs(url);
      (_this3$opts$logger = _this3.opts.logger) === null || _this3$opts$logger === void 0 || _this3$opts$logger.debug("FetchHttpApi: --> ".concat(method, " ").concat(urlForLogs));
      var headers = Object.assign({}, opts.headers || {});
      var json = (_opts$json = opts.json) !== null && _opts$json !== void 0 ? _opts$json : true;
      // We can't use getPrototypeOf here as objects made in other contexts e.g. over postMessage won't have same ref
      var jsonBody = json && (body === null || body === void 0 || (_body$constructor = body.constructor) === null || _body$constructor === void 0 ? void 0 : _body$constructor.name) === Object.name;
      if (json) {
        if (jsonBody && !headers["Content-Type"]) {
          headers["Content-Type"] = "application/json";
        }
        if (!headers["Accept"]) {
          headers["Accept"] = "application/json";
        }
      }
      var timeout = (_opts$localTimeoutMs = opts.localTimeoutMs) !== null && _opts$localTimeoutMs !== void 0 ? _opts$localTimeoutMs : _this3.opts.localTimeoutMs;
      var keepAlive = (_opts$keepAlive = opts.keepAlive) !== null && _opts$keepAlive !== void 0 ? _opts$keepAlive : false;
      var signals = [_this3.abortController.signal];
      if (timeout !== undefined) {
        signals.push(timeoutSignal(timeout));
      }
      if (opts.abortSignal) {
        signals.push(opts.abortSignal);
      }
      var data;
      if (jsonBody) {
        data = JSON.stringify(body);
      } else {
        data = body;
      }
      var {
        signal,
        cleanup
      } = anySignal(signals);
      var res;
      var start = Date.now();
      try {
        var _this3$opts$logger2;
        res = yield _this3.fetch(url, {
          signal,
          method,
          body: data,
          headers,
          mode: "cors",
          redirect: "follow",
          referrer: "",
          referrerPolicy: "no-referrer",
          cache: "no-cache",
          credentials: "omit",
          // we send credentials via headers
          keepalive: keepAlive,
          priority: opts.priority
        });
        (_this3$opts$logger2 = _this3.opts.logger) === null || _this3$opts$logger2 === void 0 || _this3$opts$logger2.debug("FetchHttpApi: <-- ".concat(method, " ").concat(urlForLogs, " [").concat(Date.now() - start, "ms ").concat(res.status, "]"));
      } catch (e) {
        var _this3$opts$logger3;
        (_this3$opts$logger3 = _this3.opts.logger) === null || _this3$opts$logger3 === void 0 || _this3$opts$logger3.debug("FetchHttpApi: <-- ".concat(method, " ").concat(urlForLogs, " [").concat(Date.now() - start, "ms ").concat(e, "]"));
        if (e.name === "AbortError") {
          throw e;
        }
        throw new ConnectionError("fetch failed", e);
      } finally {
        cleanup();
      }
      if (!res.ok) {
        throw parseErrorResponse(res, yield res.text());
      }
      if (_this3.opts.onlyData) {
        return json ? res.json() : res.text();
      }
      return res;
    })();
  }
  sanitizeUrlForLogs(url) {
    try {
      var asUrl;
      if (typeof url === "string") {
        asUrl = new URL(url);
      } else {
        asUrl = url;
      }
      // Remove the values of any URL params that could contain potential secrets
      var sanitizedQs = new URLSearchParams();
      for (var key of asUrl.searchParams.keys()) {
        sanitizedQs.append(key, "xxx");
      }
      var sanitizedQsString = sanitizedQs.toString();
      var sanitizedQsUrlPiece = sanitizedQsString ? "?".concat(sanitizedQsString) : "";
      return asUrl.origin + asUrl.pathname + sanitizedQsUrlPiece;
    } catch (_unused) {
      // defensive coding for malformed url
      return "??";
    }
  }
  /**
   * Form and return a homeserver request URL based on the given path params and prefix.
   * @param path - The HTTP path <b>after</b> the supplied prefix e.g. "/createRoom".
   * @param queryParams - A dict of query params (these will NOT be urlencoded).
   * @param prefix - The full prefix to use e.g. "/_matrix/client/v2_alpha", defaulting to this.opts.prefix.
   * @param baseUrl - The baseUrl to use e.g. "https://matrix.org", defaulting to this.opts.baseUrl.
   * @returns URL
   */
  getUrl(path, queryParams, prefix, baseUrl) {
    var baseUrlWithFallback = baseUrl !== null && baseUrl !== void 0 ? baseUrl : this.opts.baseUrl;
    var baseUrlWithoutTrailingSlash = baseUrlWithFallback.endsWith("/") ? baseUrlWithFallback.slice(0, -1) : baseUrlWithFallback;
    var url = new URL(baseUrlWithoutTrailingSlash + (prefix !== null && prefix !== void 0 ? prefix : this.opts.prefix) + path);
    if (queryParams) {
      encodeParams(queryParams, url.searchParams);
    }
    return url;
  }
}
_FetchHttpApi = FetchHttpApi;
[_initProto] = _applyDecs(_FetchHttpApi, [], [[singleAsyncExecution, 2, "tryRefreshToken"]]).e;
//# sourceMappingURL=fetch.js.map