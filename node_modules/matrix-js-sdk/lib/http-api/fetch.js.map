{"version":3,"file":"fetch.js","names":["ErrorResponse","OidcAuthError","checkObjectHasKeys","encodeParams","Method","ConnectionError","MatrixError","TokenRefreshError","HttpApiEvent","anySignal","parseErrorResponse","timeoutSignal","singleAsyncExecution","TokenRefreshOutcome","FetchHttpApi","constructor","eventEmitter","opts","_opts$useAuthorizatio","_defineProperty","_initProto","AbortController","onlyData","useAuthorizationHeader","abort","abortController","fetch","resource","options","fetchFn","globalThis","setIdBaseUrl","url","idBaseUrl","idServerRequest","method","path","params","prefix","accessToken","Error","queryParams","undefined","body","Get","fullUri","getUrl","json","headers","Authorization","concat","requestOtherUrl","authedRequest","_arguments","arguments","_this","_asyncToGenerator","paramOpts","length","_objectSpread","access_token","tokenRefreshPromise","response","request","error","errcode","doNotAttemptTokenRefresh","tryRefreshToken","Promise","allSettled","outcome","Success","Failure","inhibitLogoutEmit","emit","SessionLoggedOut","NoConsent","message","data","consent_uri","_this2","refreshToken","tokenRefreshFunction","Logout","_this2$opts$logger","logger","warn","baseUrl","_arguments2","_this3","_this3$opts$logger","_opts$json","_body$constructor","_opts$localTimeoutMs","_opts$keepAlive","urlForLogs","sanitizeUrlForLogs","debug","Object","assign","jsonBody","name","timeout","localTimeoutMs","keepAlive","signals","signal","push","abortSignal","JSON","stringify","cleanup","res","start","Date","now","_this3$opts$logger2","mode","redirect","referrer","referrerPolicy","cache","credentials","keepalive","priority","status","e","_this3$opts$logger3","ok","text","asUrl","URL","sanitizedQs","URLSearchParams","key","searchParams","keys","append","sanitizedQsString","toString","sanitizedQsUrlPiece","origin","pathname","_unused","baseUrlWithFallback","baseUrlWithoutTrailingSlash","endsWith","slice","_FetchHttpApi","_applyDecs"],"sources":["../../src/http-api/fetch.ts"],"sourcesContent":["/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * This is an internal module. See {@link MatrixHttpApi} for the public class.\n */\n\nimport { ErrorResponse as OidcAuthError } from \"oidc-client-ts\";\n\nimport { checkObjectHasKeys, encodeParams } from \"../utils.ts\";\nimport { type TypedEventEmitter } from \"../models/typed-event-emitter.ts\";\nimport { Method } from \"./method.ts\";\nimport { ConnectionError, MatrixError, TokenRefreshError } from \"./errors.ts\";\nimport {\n    HttpApiEvent,\n    type HttpApiEventHandlerMap,\n    type IHttpOpts,\n    type IRequestOpts,\n    type Body,\n} from \"./interface.ts\";\nimport { anySignal, parseErrorResponse, timeoutSignal } from \"./utils.ts\";\nimport { type QueryDict } from \"../utils.ts\";\nimport { singleAsyncExecution } from \"../utils/decorators.ts\";\n\ninterface TypedResponse<T> extends Response {\n    json(): Promise<T>;\n}\n\nexport type ResponseType<T, O extends IHttpOpts> = O extends undefined\n    ? T\n    : O extends { onlyData: true }\n      ? T\n      : TypedResponse<T>;\n\nconst enum TokenRefreshOutcome {\n    Success = \"success\",\n    Failure = \"failure\",\n    Logout = \"logout\",\n}\n\nexport class FetchHttpApi<O extends IHttpOpts> {\n    private abortController = new AbortController();\n\n    public constructor(\n        private eventEmitter: TypedEventEmitter<HttpApiEvent, HttpApiEventHandlerMap>,\n        public readonly opts: O,\n    ) {\n        checkObjectHasKeys(opts, [\"baseUrl\", \"prefix\"]);\n        opts.onlyData = !!opts.onlyData;\n        opts.useAuthorizationHeader = opts.useAuthorizationHeader ?? true;\n    }\n\n    public abort(): void {\n        this.abortController.abort();\n        this.abortController = new AbortController();\n    }\n\n    public fetch(resource: URL | string, options?: RequestInit): ReturnType<typeof globalThis.fetch> {\n        if (this.opts.fetchFn) {\n            return this.opts.fetchFn(resource, options);\n        }\n        return globalThis.fetch(resource, options);\n    }\n\n    /**\n     * Sets the base URL for the identity server\n     * @param url - The new base url\n     */\n    public setIdBaseUrl(url?: string): void {\n        this.opts.idBaseUrl = url;\n    }\n\n    public idServerRequest<T extends object = Record<string, unknown>>(\n        method: Method,\n        path: string,\n        params: Record<string, string | string[]> | undefined,\n        prefix: string,\n        accessToken?: string,\n    ): Promise<ResponseType<T, O>> {\n        if (!this.opts.idBaseUrl) {\n            throw new Error(\"No identity server base URL set\");\n        }\n\n        let queryParams: QueryDict | undefined = undefined;\n        let body: Record<string, string | string[]> | undefined = undefined;\n        if (method === Method.Get) {\n            queryParams = params;\n        } else {\n            body = params;\n        }\n\n        const fullUri = this.getUrl(path, queryParams, prefix, this.opts.idBaseUrl);\n\n        const opts: IRequestOpts = {\n            json: true,\n            headers: {},\n        };\n        if (accessToken) {\n            opts.headers!.Authorization = `Bearer ${accessToken}`;\n        }\n\n        return this.requestOtherUrl(method, fullUri, body, opts);\n    }\n\n    /**\n     * Promise used to block authenticated requests during a token refresh to avoid repeated expected errors.\n     * @private\n     */\n    private tokenRefreshPromise?: Promise<unknown>;\n\n    /**\n     * Perform an authorised request to the homeserver.\n     * @param method - The HTTP method e.g. \"GET\".\n     * @param path - The HTTP path <b>after</b> the supplied prefix e.g.\n     * \"/createRoom\".\n     *\n     * @param queryParams - A dict of query params (these will NOT be\n     * urlencoded). If unspecified, there will be no query params.\n     *\n     * @param body - The HTTP JSON body.\n     *\n     * @param paramOpts - additional options.\n     * When `paramOpts.doNotAttemptTokenRefresh` is true, token refresh will not be attempted\n     * when an expired token is encountered. Used to only attempt token refresh once.\n     *\n     * @returns Promise which resolves to\n     * ```\n     * {\n     *     data: {Object},\n     *     headers: {Object},\n     *     code: {Number},\n     * }\n     * ```\n     * If `onlyData` is set, this will resolve to the `data` object only.\n     * @returns Rejects with an error if a problem occurred.\n     * This includes network problems and Matrix-specific error JSON.\n     */\n    public async authedRequest<T>(\n        method: Method,\n        path: string,\n        queryParams?: QueryDict,\n        body?: Body,\n        paramOpts: IRequestOpts & { doNotAttemptTokenRefresh?: boolean } = {},\n    ): Promise<ResponseType<T, O>> {\n        if (!queryParams) queryParams = {};\n\n        // avoid mutating paramOpts so they can be used on retry\n        const opts = { ...paramOpts };\n\n        if (this.opts.accessToken) {\n            if (this.opts.useAuthorizationHeader) {\n                if (!opts.headers) {\n                    opts.headers = {};\n                }\n                if (!opts.headers.Authorization) {\n                    opts.headers.Authorization = \"Bearer \" + this.opts.accessToken;\n                }\n                if (queryParams.access_token) {\n                    delete queryParams.access_token;\n                }\n            } else if (!queryParams.access_token) {\n                queryParams.access_token = this.opts.accessToken;\n            }\n        }\n\n        try {\n            // Await any ongoing token refresh\n            await this.tokenRefreshPromise;\n            const response = await this.request<T>(method, path, queryParams, body, opts);\n            return response;\n        } catch (error) {\n            if (!(error instanceof MatrixError)) {\n                throw error;\n            }\n\n            if (error.errcode === \"M_UNKNOWN_TOKEN\" && !opts.doNotAttemptTokenRefresh) {\n                const tokenRefreshPromise = this.tryRefreshToken();\n                this.tokenRefreshPromise = Promise.allSettled([tokenRefreshPromise]);\n                const outcome = await tokenRefreshPromise;\n\n                if (outcome === TokenRefreshOutcome.Success) {\n                    // if we got a new token retry the request\n                    return this.authedRequest(method, path, queryParams, body, {\n                        ...paramOpts,\n                        doNotAttemptTokenRefresh: true,\n                    });\n                }\n                if (outcome === TokenRefreshOutcome.Failure) {\n                    throw new TokenRefreshError(error);\n                }\n                // Fall through to SessionLoggedOut handler below\n            }\n\n            // otherwise continue with error handling\n            if (error.errcode == \"M_UNKNOWN_TOKEN\" && !opts?.inhibitLogoutEmit) {\n                this.eventEmitter.emit(HttpApiEvent.SessionLoggedOut, error);\n            } else if (error.errcode == \"M_CONSENT_NOT_GIVEN\") {\n                this.eventEmitter.emit(HttpApiEvent.NoConsent, error.message, error.data.consent_uri);\n            }\n\n            throw error;\n        }\n    }\n\n    /**\n     * Attempt to refresh access tokens.\n     * On success, sets new access and refresh tokens in opts.\n     * @returns Promise that resolves to a boolean - true when token was refreshed successfully\n     */\n    @singleAsyncExecution\n    private async tryRefreshToken(): Promise<TokenRefreshOutcome> {\n        if (!this.opts.refreshToken || !this.opts.tokenRefreshFunction) {\n            return TokenRefreshOutcome.Logout;\n        }\n\n        try {\n            const { accessToken, refreshToken } = await this.opts.tokenRefreshFunction(this.opts.refreshToken);\n            this.opts.accessToken = accessToken;\n            this.opts.refreshToken = refreshToken;\n            // successfully got new tokens\n            return TokenRefreshOutcome.Success;\n        } catch (error) {\n            this.opts.logger?.warn(\"Failed to refresh token\", error);\n            if (error instanceof OidcAuthError || error instanceof MatrixError) {\n                return TokenRefreshOutcome.Logout;\n            }\n            return TokenRefreshOutcome.Failure;\n        }\n    }\n\n    /**\n     * Perform a request to the homeserver without any credentials.\n     * @param method - The HTTP method e.g. \"GET\".\n     * @param path - The HTTP path <b>after</b> the supplied prefix e.g.\n     * \"/createRoom\".\n     *\n     * @param queryParams - A dict of query params (these will NOT be\n     * urlencoded). If unspecified, there will be no query params.\n     *\n     * @param body - The HTTP JSON body.\n     *\n     * @param opts - additional options\n     *\n     * @returns Promise which resolves to\n     * ```\n     * {\n     *  data: {Object},\n     *  headers: {Object},\n     *  code: {Number},\n     * }\n     * ```\n     * If `onlyData</code> is set, this will resolve to the <code>data`\n     * object only.\n     * @returns Rejects with an error if a problem\n     * occurred. This includes network problems and Matrix-specific error JSON.\n     */\n    public request<T>(\n        method: Method,\n        path: string,\n        queryParams?: QueryDict,\n        body?: Body,\n        opts?: IRequestOpts,\n    ): Promise<ResponseType<T, O>> {\n        const fullUri = this.getUrl(path, queryParams, opts?.prefix, opts?.baseUrl);\n        return this.requestOtherUrl<T>(method, fullUri, body, opts);\n    }\n\n    /**\n     * Perform a request to an arbitrary URL.\n     * @param method - The HTTP method e.g. \"GET\".\n     * @param url - The HTTP URL object.\n     *\n     * @param body - The HTTP JSON body.\n     *\n     * @param opts - additional options\n     *\n     * @returns Promise which resolves to data unless `onlyData` is specified as false,\n     * where the resolved value will be a fetch Response object.\n     * @returns Rejects with an error if a problem\n     * occurred. This includes network problems and Matrix-specific error JSON.\n     */\n    public async requestOtherUrl<T>(\n        method: Method,\n        url: URL | string,\n        body?: Body,\n        opts: Pick<IRequestOpts, \"headers\" | \"json\" | \"localTimeoutMs\" | \"keepAlive\" | \"abortSignal\" | \"priority\"> = {},\n    ): Promise<ResponseType<T, O>> {\n        const urlForLogs = this.sanitizeUrlForLogs(url);\n        this.opts.logger?.debug(`FetchHttpApi: --> ${method} ${urlForLogs}`);\n\n        const headers = Object.assign({}, opts.headers || {});\n        const json = opts.json ?? true;\n        // We can't use getPrototypeOf here as objects made in other contexts e.g. over postMessage won't have same ref\n        const jsonBody = json && body?.constructor?.name === Object.name;\n\n        if (json) {\n            if (jsonBody && !headers[\"Content-Type\"]) {\n                headers[\"Content-Type\"] = \"application/json\";\n            }\n\n            if (!headers[\"Accept\"]) {\n                headers[\"Accept\"] = \"application/json\";\n            }\n        }\n\n        const timeout = opts.localTimeoutMs ?? this.opts.localTimeoutMs;\n        const keepAlive = opts.keepAlive ?? false;\n        const signals = [this.abortController.signal];\n        if (timeout !== undefined) {\n            signals.push(timeoutSignal(timeout));\n        }\n        if (opts.abortSignal) {\n            signals.push(opts.abortSignal);\n        }\n\n        let data: BodyInit;\n        if (jsonBody) {\n            data = JSON.stringify(body);\n        } else {\n            data = body as BodyInit;\n        }\n\n        const { signal, cleanup } = anySignal(signals);\n\n        let res: Response;\n        const start = Date.now();\n        try {\n            res = await this.fetch(url, {\n                signal,\n                method,\n                body: data,\n                headers,\n                mode: \"cors\",\n                redirect: \"follow\",\n                referrer: \"\",\n                referrerPolicy: \"no-referrer\",\n                cache: \"no-cache\",\n                credentials: \"omit\", // we send credentials via headers\n                keepalive: keepAlive,\n                priority: opts.priority,\n            });\n\n            this.opts.logger?.debug(\n                `FetchHttpApi: <-- ${method} ${urlForLogs} [${Date.now() - start}ms ${res.status}]`,\n            );\n        } catch (e) {\n            this.opts.logger?.debug(`FetchHttpApi: <-- ${method} ${urlForLogs} [${Date.now() - start}ms ${e}]`);\n            if ((<Error>e).name === \"AbortError\") {\n                throw e;\n            }\n            throw new ConnectionError(\"fetch failed\", <Error>e);\n        } finally {\n            cleanup();\n        }\n\n        if (!res.ok) {\n            throw parseErrorResponse(res, await res.text());\n        }\n\n        if (this.opts.onlyData) {\n            return json ? res.json() : res.text();\n        }\n        return res as ResponseType<T, O>;\n    }\n\n    private sanitizeUrlForLogs(url: URL | string): string {\n        try {\n            let asUrl: URL;\n            if (typeof url === \"string\") {\n                asUrl = new URL(url);\n            } else {\n                asUrl = url;\n            }\n            // Remove the values of any URL params that could contain potential secrets\n            const sanitizedQs = new URLSearchParams();\n            for (const key of asUrl.searchParams.keys()) {\n                sanitizedQs.append(key, \"xxx\");\n            }\n            const sanitizedQsString = sanitizedQs.toString();\n            const sanitizedQsUrlPiece = sanitizedQsString ? `?${sanitizedQsString}` : \"\";\n\n            return asUrl.origin + asUrl.pathname + sanitizedQsUrlPiece;\n        } catch {\n            // defensive coding for malformed url\n            return \"??\";\n        }\n    }\n    /**\n     * Form and return a homeserver request URL based on the given path params and prefix.\n     * @param path - The HTTP path <b>after</b> the supplied prefix e.g. \"/createRoom\".\n     * @param queryParams - A dict of query params (these will NOT be urlencoded).\n     * @param prefix - The full prefix to use e.g. \"/_matrix/client/v2_alpha\", defaulting to this.opts.prefix.\n     * @param baseUrl - The baseUrl to use e.g. \"https://matrix.org\", defaulting to this.opts.baseUrl.\n     * @returns URL\n     */\n    public getUrl(path: string, queryParams?: QueryDict, prefix?: string, baseUrl?: string): URL {\n        const baseUrlWithFallback = baseUrl ?? this.opts.baseUrl;\n        const baseUrlWithoutTrailingSlash = baseUrlWithFallback.endsWith(\"/\")\n            ? baseUrlWithFallback.slice(0, -1)\n            : baseUrlWithFallback;\n        const url = new URL(baseUrlWithoutTrailingSlash + (prefix ?? this.opts.prefix) + path);\n        if (queryParams) {\n            encodeParams(queryParams, url.searchParams);\n        }\n        return url;\n    }\n}\n"],"mappings":"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","ignoreList":[]}